package exporter

import (
	"context"
	"log"
	"sync"

	"github.com/dwelch0/stackrox-cve-exporter/pkg/exporter/gql"
)

type imageVulnsByCluster struct {
	clusterName string
	nsVulns     []*gql.GetImageVulnerabilitiesByNamespaceIDResponse
	errs        []error
}

func (e *exporter) collect(ctx context.Context) {
	clusterIDs, err := gql.ListClusterIDs(ctx, e.gqlClient)
	if err != nil {
		log.Println(err)
	}

	wg := &sync.WaitGroup{}
	ch := make(chan imageVulnsByCluster)
	sem := make(chan struct{}, 3) // value here is increased by factor of 10 due to processClusterVulns
	for _, cluster := range clusterIDs.GetClusters() {
		sem <- struct{}{}
		wg.Add(1)

		go func(id, name string) {
			defer func() { <-sem }()
			defer wg.Done()
			e.processClusterVulns(ctx, ch, id, name)
		}(cluster.GetId(), cluster.GetName())
	}

	go func() {
		wg.Wait()
		close(ch)
		close(sem)
	}()

	for clusterResult := range ch {
		if len(clusterResult.errs) > 0 {
			for err := range clusterResult.errs {
				log.Println(err)
			}
		}
	}

}

type imageVulnsByNS struct {
	result *gql.GetImageVulnerabilitiesByNamespaceIDResponse
	err    error
}

func (e *exporter) processClusterVulns(ctx context.Context, clusterCh chan<- imageVulnsByCluster, id, name string) {
	// collect name/id of namespaces in cluster
	nsMetadatas, err := gql.GetNamespaceMetadatasByClusterID(ctx, e.gqlClient, id)
	if err != nil {
		clusterCh <- imageVulnsByCluster{errs: []error{err}}
		return
	}

	// concurrently retrieve image vulns by namespace
	wg := &sync.WaitGroup{}
	nsCh := make(chan imageVulnsByNS)
	sem := make(chan struct{}, 10) // arbitrary value. TODO: evaluate and adjust/parameterize

	for _, ns := range nsMetadatas.Cluster.GetNamespaces() {
		sem <- struct{}{}
		wg.Add(1)

		go func(nsId string) {
			defer func() { <-sem }() // release one from buffer
			defer wg.Done()

			imageVulns, err := gql.GetImageVulnerabilitiesByNamespaceID(ctx, e.gqlClient, nsId)
			if err != nil {
				nsCh <- imageVulnsByNS{err: err}
			} else {
				nsCh <- imageVulnsByNS{result: imageVulns}
			}
		}(ns.Metadata.GetId())
	}

	go func() {
		wg.Wait()
		close(nsCh)
		close(sem)
	}()

	result := imageVulnsByCluster{
		clusterName: name,
	}

	for ns := range nsCh {
		if ns.err != nil {
			result.errs = append(result.errs, ns.err)
		}
		result.nsVulns = append(result.nsVulns, ns.result)
	}

	clusterCh <- result
}
